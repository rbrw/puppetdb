(ns puppetlabs.puppetdb.import
  "Import utility

   This is a command-line tool for importing data into PuppetDB. It expects
   as input a tarball generated by the PuppetDB `export` command-line tool."
  (:import [org.apache.commons.compress.archivers.tar TarArchiveEntry]
           [puppetlabs.puppetdb.archive TarGzReader])
  (:require [clojure.java.io :as io]
            [clojure.tools.logging :as log]
            [puppetlabs.puppetdb.archive :as archive]
            [puppetlabs.puppetdb.reports :as reports]
            [puppetlabs.puppetdb.export :as export]
            [puppetlabs.puppetdb.utils :as utils]
            [puppetlabs.puppetdb.cheshire :as json]
            [puppetlabs.puppetdb.schema :refer [defn-validated]]
            [puppetlabs.puppetdb.utils :as utils]))

(defn file-pattern
  [entity]
  (re-pattern (str "^" (.getPath (io/file utils/export-root-dir entity ".*\\.json")) "$")))

(def after-certname-length
  "The format is <certname>-<date hash><suffix>. This is a count of
  the characters after the certname"
  (+ 1
     40
     (count export/file-suffix)))

(def export-root-dir-length
  (count utils/export-root-dir))

(defn extract-certname [^String command-type ^String path]
  (let [path-length (.length path)
        prefix-length (+ export-root-dir-length
                         (.length command-type)
                         2)]
    (subs path prefix-length (- path-length after-certname-length))))

(defn extract-facts-certname [^String path]
  (let [prefix-length (+ export-root-dir-length
                         (.length "facts")
                         2)]
    (subs path prefix-length (- (.length path) (count export/file-suffix)))))

(defn-validated process-tar-entry
  "Determine the type of an entry from the exported archive, and process it
  accordingly."
  [command-fn
   tar-reader :- TarGzReader
   tar-entry :- TarArchiveEntry
   command-versions]
  (let [path (.getName tar-entry)]
    (condp re-find path
      (file-pattern "catalogs")
      (do (log/infof "Importing catalog from archive entry '%s'" path)
          ;; NOTE: these submissions are async and we have no guarantee that they
          ;;   will succeed. We might want to add something at the end of the import
          ;;   that polls puppetdb until the command queue is empty, then does a
          ;;   query to the /nodes endpoint and shows the set difference between
          ;;   the list of nodes that we submitted and the output of that query
          (command-fn :replace-catalog
                      (:replace_catalog command-versions)
                      (extract-certname "catalogs" path)
                      (-> tar-reader
                          utils/read-json-content
                          json/generate-string
                          (.getBytes "UTF-8")
                          java.io.ByteArrayInputStream.)))
      (file-pattern "reports")
      (do (log/infof "Importing report from archive entry '%s'" path)
          (command-fn :store-report
                      (:store_report command-versions)
                      (extract-certname "reports" path)
                      (-> tar-reader
                          (utils/read-json-content true)
                          json/generate-string
                          (.getBytes "UTF-8")
                          java.io.ByteArrayInputStream.)))
      (file-pattern "facts")
      (do (log/infof "Importing facts from archive entry '%s'" path)
          (command-fn :replace-facts
                      (:replace_facts command-versions)
                      (extract-facts-certname path)
                      (-> tar-reader
                          utils/read-json-content
                          json/generate-string
                          (.getBytes "UTF-8")
                          java.io.ByteArrayInputStream.)))
      nil)))

(def metadata-path
  (.getPath (io/file utils/export-root-dir export/export-metadata-file-name)))

(defn parse-metadata
  "Parses the export metadata file to determine, e.g., what versions of the
  commands should be used during import."
  [tar-reader]
  {:post [(map? %)
          (:command_versions %)]}
  (when-not (archive/find-entry tar-reader metadata-path)
    (throw (IllegalStateException.
            (format "Unable to find export metadata file '%s' in archive"
                    metadata-path))))
  (utils/read-json-content tar-reader true))

(defn import!
  [infile command-fn]
  (with-open [tar-reader (archive/tarball-reader infile)]
    (let [command-versions (:command_versions (parse-metadata tar-reader))]
      (doseq [tar-entry (archive/all-entries tar-reader)]
        (process-tar-entry command-fn tar-reader tar-entry command-versions)))))
